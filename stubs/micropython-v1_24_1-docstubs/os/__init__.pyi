"""
Basic "operating system" services.

MicroPython module: https://docs.micropython.org/en/v1.24.0/library/os.html

CPython module: :mod:`python:os` https://docs.python.org/3/library/os.html .

The ``os`` module contains functions for filesystem access and mounting,
terminal redirection and duplication, and the ``uname`` and ``urandom``
functions.
"""

# source version: v1.24.1
# origin module:: repos/micropython/docs/library/os.rst
from __future__ import annotations
from _typeshed import Incomplete
from typing import Union, overload, IO, Any, Iterator, Optional, Tuple
from typing_extensions import deprecated, TypeVar, TypeAlias, Awaitable
from _mpy_shed import mp_available, uname_result

@deprecated("The `VfsFat` class is deprecated, use `vfs.VfsFat` instead.")
class VfsFat:
    """
    See `vfs.VfsFat`.
    """

    def __init__(self, block_dev) -> None: ...

@deprecated("The `VfsLfs1` class is deprecated, use `vfs.VfsLfs1` instead.")
class VfsLfs1:
    """
    See `vfs.VfsLfs1`.
    """

    def __init__(self, block_dev, readsize=32, progsize=32, lookahead=32) -> None: ...

@deprecated("The `VfsLfs2` class is deprecated, use `vfs.VfsLfs2` instead.")
class VfsLfs2:
    """
    See `vfs.VfsLfs2`.
    """

    def __init__(self, block_dev, readsize=32, progsize=32, lookahead=32, mtime=True) -> None: ...

@deprecated("The `VfsPosix` class is deprecated, use `vfs.VfsPosix` instead.")
class VfsPosix:
    """
    See `vfs.VfsPosix`.
    """

    def __init__(self, root=None) -> None: ...

def uname() -> uname_result:
    """
    Return a tuple (possibly a named tuple) containing information about the
    underlying machine and/or its operating system.  The tuple has five fields
    in the following order, each of them being a string:

         * ``sysname`` -- the name of the underlying system
         * ``nodename`` -- the network name (can be the same as ``sysname``)
         * ``release`` -- the version of the underlying system
         * ``version`` -- the MicroPython version and build date
         * ``machine`` -- an identifier for the underlying hardware (eg board, CPU)
    """
    ...

@mp_available()  # force merge
def urandom(n: int) -> bytes:
    """
    Return a bytes object with *n* random bytes. Whenever possible, it is
    generated by the hardware random number generator.
    """
    ...

@mp_available()  # force merge
def chdir(path) -> Incomplete:
    """
    Change current directory.
    """
    ...

@mp_available()  # force merge
def getcwd() -> Incomplete:
    """
    Get the current directory.
    """
    ...

@overload
def ilistdir(dir: Union[str, bytes]) -> Iterator[Union[Tuple[str, int, int], Tuple[str, int, int, int]]]:
    """
    This function returns an iterator which then yields tuples corresponding to
    the entries in the directory that it is listing.  With no argument it lists the
    current directory, otherwise it lists the directory given by *dir*.

    The tuples have the form *(name, type, inode[, size])*:

     - *name* is a string (or bytes if *dir* is a bytes object) and is the name of
       the entry;
     - *type* is an integer that specifies the type of the entry, with 0x4000 for
       directories and 0x8000 for regular files;
     - *inode* is an integer corresponding to the inode of the file, and may be 0
       for filesystems that don't have such a notion.
     - Some platforms may return a 4-tuple that includes the entry's *size*.  For
       file entries, *size* is an integer representing the size of the file
       or -1 if unknown.  Its meaning is currently undefined for directory
       entries.
    """
    ...

@overload
def ilistdir() -> Iterator[Union[Tuple[str, int, int], Tuple[str, int, int, int]]]: ...
@mp_available()  # force merge
def listdir(dir: Optional[Any] = None) -> Incomplete:
    """
    With no argument, list the current directory.  Otherwise list the given directory.
    """
    ...

@mp_available()  # force merge
def mkdir(path) -> Incomplete:
    """
    Create a new directory.
    """
    ...

@mp_available()  # force merge
def remove(path) -> None:
    """
    Remove a file.
    """
    ...

@mp_available()  # force merge
def rmdir(path) -> None:
    """
    Remove a directory.
    """
    ...

@mp_available()  # force merge
def rename(old_path, new_path) -> None:
    """
    Rename a file.
    """
    ...

def stat(path: str | bytes) -> Tuple:
    """
    Get the status of a file or directory.
    """
    ...

@mp_available()  # force merge
def statvfs(path) -> Tuple:
    """
    Get the status of a filesystem.

    Returns a tuple with the filesystem information in the following order:

         * ``f_bsize`` -- file system block size
         * ``f_frsize`` -- fragment size
         * ``f_blocks`` -- size of fs in f_frsize units
         * ``f_bfree`` -- number of free blocks
         * ``f_bavail`` -- number of free blocks for unprivileged users
         * ``f_files`` -- number of inodes
         * ``f_ffree`` -- number of free inodes
         * ``f_favail`` -- number of free inodes for unprivileged users
         * ``f_flag`` -- mount flags
         * ``f_namemax`` -- maximum filename length

    Parameters related to inodes: ``f_files``, ``f_ffree``, ``f_avail``
    and the ``f_flags`` parameter may return ``0`` as they can be unavailable
    in a port-specific implementation.
    """
    ...

@mp_available()  # force merge
def sync() -> None:
    """
    Sync all filesystems.
    """
    ...

@mp_available()  # force merge
def dupterm(stream_object, index=0, /) -> IO:
    """
    Duplicate or switch the MicroPython terminal (the REPL) on the given `stream`-like
    object. The *stream_object* argument must be a native stream object, or derive
    from ``io.IOBase`` and implement the ``readinto()`` and
    ``write()`` methods.  The stream should be in non-blocking mode and
    ``readinto()`` should return ``None`` if there is no data available for reading.

    After calling this function all terminal output is repeated on this stream,
    and any input that is available on the stream is passed on to the terminal input.

    The *index* parameter should be a non-negative integer and specifies which
    duplication slot is set.  A given port may implement more than one slot (slot 0
    will always be available) and in that case terminal input and output is
    duplicated on all the slots that are set.

    If ``None`` is passed as the *stream_object* then duplication is cancelled on
    the slot given by *index*.

    The function returns the previous stream-like object in the given slot.
    """
    ...

# Deprecated functions and classes
# The following functions and classes have been moved to the vfs module.

@mp_available()  # force merge
@deprecated("The `mount` function is deprecated, use `vfs.mount` instead.")
def mount(fsobj, mount_point, *, readonly=False) -> Incomplete:
    """
    See `vfs.mount`.
    """
    ...

@mp_available()  # force merge
@deprecated("The `umount` function is deprecated, use `vfs.umount` instead.")
def umount(mount_point) -> Incomplete:
    """
    See `vfs.umount`.
    """
    ...

@mp_available()  # force merge
def dupterm_notify(obj_in: Any, /) -> None:
    # https://github.com/orgs/micropython/discussions/16680
    # https://github.com/micropython/micropython/issues/17799
    """
    Notify the MicroPython REPL that input is available on a stream-like object
    previously registered via `os.dupterm()`.

    This function should be called by custom stream implementations (e.g., UART,
    Bluetooth, or other non-USB REPL streams) to inform the REPL that input is
    ready to be read. Proper use ensures that special characters such as
    Ctrl+C (used to trigger KeyboardInterrupt) are processed promptly by the
    REPL, enabling expected interruption behavior for user code.

    Args:
        obj_in: Is ignored by dupterm_notify, but is required to allow calling
        dupterm_notify from an interrupt handler such as UART.irq()
    Note:
        - If input is available (including control characters like Ctrl+C),
          call this function to ensure responsive REPL behavior.
        - If omitted, input from the custom stream may not be detected or
          processed until the next REPL poll, potentially delaying KeyboardInterrupts
          or other control signals.
        - This is especially important for UART, Bluetooth, or other
          non-standard REPL connections, where automatic notification is not guaranteed.

    Example:
        from machine import UART
        import os
        uart = UART(0)
        uart.irq(os.dupterm_notify, machine.UART.IRQ_RX)  # or UART.IRQ_RXIDLE
        os.dupterm(uart, 0)
    """
    ...
